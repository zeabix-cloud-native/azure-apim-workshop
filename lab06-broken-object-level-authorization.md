# Lab-06 - Broken Object Level Authorization

In the previous labs we have successfully configure Azure APIM to be able to protect our API using 
OAuth2.0. However, we have not done the fine-grain authorization yet. You can notice that every users in our system has the same privileges, it can access to the same piece of information through the API.

In the real-world situation, not every users can access to every data. For example, `user-a` should be able to access to his own `user profile` information, but MUST NOT able to access to `user-profile` of other users.

In this scenario, we called `Broken Object Level Authorization`, Because the authorization process has not done in the level of the object.

In the old days, the only way to fix this is by application logic. However, with Azure APIM, we can off-load some of the task to Azure APIM


### Exercise 1 - Examine the problem
In this exercise we will setup `Profile API V1` which will show you how the `Broken Object Level Authorization` works

- Create API Name `Profile API`
    + Backend: `https://workshop-api.z-unified.com/profile-service`
    + Prefix: `profile-service`

- Configure `cors` (All Operations)
- Configure `Validate JWT` (All Operations)
- Add Operation `Get Profile` with path `/v1/profiles/{id}`, Method `GET`
- Use the `Postman` tool or `curl` command line to get the user profile for these user id
    +
    +
    +

NOTE: We can see that even we protect the API with OAuth2.0, any valid users are able to access other's users information. This is really dangerous vulnerabilities

### Exercise 2 - Discussion for Solution
Let explore, the user profile data
```json
{
    "id": "string",
    "username": "string",
    "firstname": "string",
    "avatar": "string",
    "dob": "string",
    "address": "string",
    "mobile": "string",
}
```

The solution is to use the JWT token which is signed from Azure AD to protect the data, We have to create the link between JWT token and the user profile data for each user

NOTE
- Claims `oid` in JWT token is the unique with in the same tanent
- Claims `sub` cannot be used since it is unique within only the same client application, e.g. SPA, So it's not recommended to use it


### Exercise 3 - OID link with user data
Application may need to adjust a little bit by adding `oid` fields to user profile data so that we can relate between JWT and the data, so the data would be

```json
{
    "id": "string",
    "username": "string",
    "firstname": "string",
    "avatar": "string",
    "dob": "string",
    "address": "string",
    "mobile": "string",
    "oid": "string
}
```

## Exercise 4 - Explore new API to Register/Setup user account with oid
In order to have fields `oid` link with user profile data, we need to update our API for setup user account, which will extract `oid` and then update it into the user profile

API Endpoint: `https://workshop-api.z-unified.com/v2/profiles`

Method: `POST`

Example Request Body
```
{
    "username": "string",
    "firstname": "string",
    "avatar": "string",
    "dob": "string",
    "address": "string",
    "mobile": "string",
    "oid": "string
}
```

NOTE: The `id` will be automatically generated by backend services

#### Demo Time!!! 


### Exercise 5 - Configure APIM for new profile API
- Login to Azure Portal and navigate to Azure APIM
- Create `Profile API` (Delete the old api, if you already have one)
- Disable `Subscription`
- At `All Operations` setup policy
    + `cors`
    + `validate-jwt`
- Ensure that you add scopes `profiles` into the APIM application registration in Azure AD, and update source code of SPA accordingly
- (Optional) or you can create policy by code, But ensure that you chaged mandatory fields to match your APIM registration and SPA registration in Azure AD, e.g. `audiences`, 
```
<!--
    IMPORTANT:
    - Policy elements can appear only within the <inbound>, <outbound>, <backend> section elements.
    - To apply a policy to the incoming request (before it is forwarded to the backend service), place a corresponding policy element within the <inbound> section element.
    - To apply a policy to the outgoing response (before it is sent back to the caller), place a corresponding policy element within the <outbound> section element.
    - To add a policy, place the cursor at the desired insertion point and select a policy from the sidebar.
    - To remove a policy, delete the corresponding policy statement from the policy document.
    - Position the <base> element within a section element to inherit all policies from the corresponding section element in the enclosing scope.
    - Remove the <base> element to prevent inheriting policies from the corresponding section element in the enclosing scope.
    - Policies are applied in the order of their appearance, from the top down.
    - Comments within policy elements are not supported and may disappear. Place your comments between policy elements or at a higher level scope.
-->
<policies>
    <inbound>
        <base />
        <validate-jwt header-name="Authorization" failed-validation-httpcode="401" require-expiration-time="true" require-scheme="Bearer" require-signed-tokens="true" clock-skew="10" output-token-variable-name="jwt">
            <openid-config url="https://login.microsoftonline.com/d13ad595-5883-4b3a-a953-bc0f981c0c35/v2.0/.well-known/openid-configuration" />
            <audiences>
                <audience>api://a49c40ab-9685-475e-8550-8945a36a05fe</audience>
            </audiences>
            <issuers>
                <issuer>https://sts.windows.net/d13ad595-5883-4b3a-a953-bc0f981c0c35/</issuer>
            </issuers>
            <required-claims>
                <claim name="scp" match="all" separator=" ">
                    <value>profiles</value>
                </claim>
            </required-claims>
        </validate-jwt>
        <cors allow-credentials="false">
            <allowed-origins>
                <origin>*</origin>
            </allowed-origins>
            <allowed-methods>
                <method>*</method>
            </allowed-methods>
            <allowed-headers>
                <header>*</header>
            </allowed-headers>
        </cors>
    </inbound>
    <backend>
        <base />
    </backend>
    <outbound>
        <base />
    </outbound>
    <on-error>
        <base />
    </on-error>
</policies>
```

- Add Operation name `Setup Account`
    + Method: `POST`
    + URL: `/v2/profiles`

- Update policy of `Setup Account` API by this policy
```
<policies>
    <inbound>
        <base />
        <set-body>@{
            JObject reqBody = context.Request.Body.As<JObject>(true);
            String firstname = ((Jwt)context.Variables["jwt"]).Claims["given_name"][0];
            String lastname = ((Jwt)context.Variables["jwt"]).Claims["family_name"][0];
            String oid = ((Jwt)context.Variables["jwt"]).Claims["oid"][0];
            String email = ((Jwt)context.Variables["jwt"]).Claims["email"][0];

            reqBody["oid"] = oid;
            reqBody["firstname"] = firstname;
            reqBody["lastname"] = lastname;
            reqBody["username"] = email;

            return reqBody.ToString();
        }</set-body>
    </inbound>
    <backend>
        <base />
    </backend>
    <outbound>
        <base />
    </outbound>
    <on-error>
        <base />
    </on-error>
</policies>
```

#### Time to Walk-through source code!!!!
In this policy, we do not allow users to update these following fields directly, instead we extract the value from JWT token.
this will improve the security of the API which the instruders are unable to forge the fake request with fake information, e.g.
`oid`


### Exercise 6 - Update profile api
In the version 1, `/v1/profiles/{id}`, we get user profile based on the user id, in this exercise we will explore another changes that we have made to backend APIs by adding another API to get user profile by `oid`

- In the `Profile API` from exercise 5, add another operation called `Get Profile`
    + Method: `GET`
    + URL: `/v2/profiles/me`

NOTE: We can see that we do not allow user to put in the `oid` as the parameters of the request, instead we will extract `oid` from JWT and rewrite URL before request to backend service.

With this technique, there is no way that any users will get the user profile of others, since our API do not allow them to do so

- Apply these policy to `Get Profile`
```
<policies>
    <inbound>
        <base />
        <rewrite-uri template="@{
            String oid = ((Jwt)context.Variables["jwt"]).Claims["oid"][0];
            return $"/v2/profiles/{oid}";
        }" copy-unmatched-params="true" />
    </inbound>
    <backend>
        <base />
    </backend>
    <outbound>
        <base />
    </outbound>
    <on-error>
        <base />
    </on-error>
</policies>
```

You can see that in this policy we using `rewrite-uri` and then apply the logic to extract `oid` claim from JWT and then rewrite the URL to backend service as `/v2/profiles/{oid}`

### Exercise 7 - Testing with SPA
- In the SPA, update source code `.env` file
```
REACT_APP_PROFILE_API_ENDPOINT=https://apim-workshop.azure-api.net/profile-service
```

Ensure that the url is from your APIM `Profile API`
- Restart SPA, run `npm start` again
- Open Browser, `http://localhost:3000`
- Login With Azure AD
- Then go to menu `Profile`

It should ask you to register account with prefill data, e.g. `Firstname`, `Lastname`
- Input the registration detail
- click `Submit`
- Explore the `Network Inspection` of your browser, to see the request and response

